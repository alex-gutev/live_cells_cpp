"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[180],{3389:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>r,frontMatter:()=>c,metadata:()=>i,toc:()=>d});var t=l(4848),s=l(8453);const c={title:"Cells",description:"Introduction to the cell -- the basic building block of Live Cells.",sidebar_position:1},a="Cells",i={id:"basics/cells",title:"Cells",description:"Introduction to the cell -- the basic building block of Live Cells.",source:"@site/docs/basics/cells.md",sourceDirName:"basics",slug:"/basics/cells",permalink:"/docs/basics/cells",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Cells",description:"Introduction to the cell -- the basic building block of Live Cells.",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Basics",permalink:"/docs/category/basics"},next:{title:"Cell Expressions",permalink:"/docs/basics/cell-expressions"}},o={},d=[{value:"Mutable Cells",id:"mutable-cells",level:2},{value:"Observing Cells",id:"observing-cells",level:2},{value:"Computed Cells",id:"computed-cells",level:2},{value:"Batch Updates",id:"batch-updates",level:2},{value:"Cell Types",id:"cell-types",level:2},{value:"Dynamically Typed Cells",id:"dynamically-typed-cells",level:3},{value:"Memory Management",id:"memory-management",level:3}];function h(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"cells",children:"Cells"}),"\n",(0,t.jsx)(n.p,{children:"A cell is an object with a value and a set of observers that react to\nchanges in its value, you'll see exactly what that means in a moment."}),"\n",(0,t.jsxs)(n.p,{children:["There are a number of ways to create cells. The simplest cells is the\nconstant cell, created with ",(0,t.jsx)(n.code,{children:"live_cells::value(...)"}),", which holds a\nconstant value."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Constant Cells"',children:'auto a = live_cells::value(1);\nauto b = live_cells::value<std::string>("hello world");\nauto c = live_cells::value(some_value);\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"live_cells::value"})," takes the constant value and wraps it in a\nconstant cell. The values of constant cells never change."]}),"\n",(0,t.jsxs)(n.p,{children:["The value of a cell is accessed using the ",(0,t.jsx)(n.code,{children:"value()"})," accessor method."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Accessing cell values"',children:"std::cout << a.value() << std::endl; // Prints: 1\nstd::cout << b.value() << std::endl; // Prints: 'hello world'\nstd::cout << c.value() << std::endl; // Prints the value of `someValue`\n"})}),"\n",(0,t.jsx)(n.h2,{id:"mutable-cells",children:"Mutable Cells"}),"\n",(0,t.jsxs)(n.p,{children:["Mutable cells, created with ",(0,t.jsx)(n.code,{children:"live_cells::variable(...)"}),", hold a value\nthat can be set with the ",(0,t.jsx)(n.code,{children:"value(...)"})," setter method, which takes the\nnew value."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Creating mutable cells"',children:"auto a = live_cells::variable(0);\n\nstd::cout << a.value() << std::endl; // Prints: 0\n\n// Set the value of a to 3\na.value(3);\nstd::cout << a.value() << std::endl; // Prints: 3\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"live_cells::variable"})," takes the initial value of the cell."]}),"\n",(0,t.jsx)(n.h2,{id:"observing-cells",children:"Observing Cells"}),"\n",(0,t.jsxs)(n.p,{children:["When the value of a cell changes, its observers are notified of the\nchange. The simplest way to demonstrate this is to set up a ",(0,t.jsx)(n.em,{children:"watch\nfunction"})," using ",(0,t.jsx)(n.code,{children:"live_cells::watch"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Observing cells"',children:'auto a = live_cells::variable(0);\nauto b = live_cells::variable(1);\n\n// Set up a watch function observing cells `a` and `b`\nauto watcher = live_cells::watch([=] {\n    std::cout << a();\n    std::cout << ", ";\n    std::cout << b();\n});\n\na.value(5);  // Prints: 5, 1\nb.value(10); // Prints: 5, 10\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"live_cells::watch"})," takes a watch function and registers it to be\ncalled when the values of the cells referenced within it change. In\nthe example above, a watch function that prints the values of cells\n",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," to the console, is defined. This function is called\nautomatically when the value of either ",(0,t.jsx)(n.code,{children:"a"})," or ",(0,t.jsx)(n.code,{children:"b"})," changes."]}),"\n",(0,t.jsxs)(n.p,{children:["There are a couple of important points to keep in mind when using\n",(0,t.jsx)(n.code,{children:"live_cells::watch"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The watch function is called once immediately when\n",(0,t.jsx)(n.code,{children:"live_cells::watch"})," is called, to determine what cells are\nreferenced by it."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"live_cells::watch"})," automatically tracks which cells are referenced\nwithin it, and registers it to be called when their values\nchange. This works even when the cells are referenced conditionally."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Within the watch function, the values of cells have to be referenced\nwith the function call operator, rather than the ",(0,t.jsx)(n.code,{children:"value()"}),"\nmethod. The difference between the two is that ",(0,t.jsx)(n.code,{children:"value()"})," only\nreferences the value, whereas the function call operator also tracks\nit as a referenced cell."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"important",children:(0,t.jsxs)(n.p,{children:["Within a watch function, the value of a cell is referenced using the\nfunction call syntax rather than the ",(0,t.jsx)(n.code,{children:"value()"})," method."]})}),"\n",(0,t.jsxs)(n.p,{children:["Every call to ",(0,t.jsx)(n.code,{children:"live_cells::watch"})," adds a new watch function, for\nexample:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Multiple watch functions"',children:'auto watcher2 = live_cells::watch([=] {\n\tstd::cout << "A = " << a() << std::endl;\n});\n\n// Prints: 20, 10\n// Also prints: A = 20\na.value(20);\n\n// Prints: 20, 1\nb.value(1);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The watch function defined above, ",(0,t.jsx)(n.code,{children:"watcher2"}),", observes the value of\n",(0,t.jsx)(n.code,{children:"a"})," only. Changing the value of ",(0,t.jsx)(n.code,{children:"a"})," results in both watch functions\nbeing called. Changing the value of ",(0,t.jsx)(n.code,{children:"b"})," only results in the first\nwatch function being called, since the second watch function does not\nreference ",(0,t.jsx)(n.code,{children:"b"})," and hence is not observing it."]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["When you no longer need the watch function to be called, call ",(0,t.jsx)(n.code,{children:"stop"}),'\non the "handle" returned by ',(0,t.jsx)(n.code,{children:"live_cells::watch"}),":"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"watcher1->stop();\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"live_cells::watch"})," returns a shared pointer (",(0,t.jsx)(n.code,{children:"std::shared_ptr"}),")\nholding a handle (",(0,t.jsx)(n.code,{children:"live_cells::watcher"}),") to the watch function. This\nhandle provides the ",(0,t.jsx)(n.code,{children:"stop()"})," method, which stops the watch function\nfrom being called for further changes in the cell values."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Prints: 2, 1\nb.value(2);\n\nwatcher1->stop();\n\n// Doesn't print anything\nb.value(3);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The watch function is also stopped automatically when the last\n",(0,t.jsx)(n.code,{children:"shared_ptr"})," point to the handle, is destroyed."]}),"\n",(0,t.jsxs)(n.admonition,{type:"caution",children:[(0,t.jsxs)(n.p,{children:["Due to the watch function being stopped automatically on destruction,\nyou should always assign the handle returned by ",(0,t.jsx)(n.code,{children:"live_cells::watch"})," to\na variable, even if you don't intend on using it directly. If you\ndon't assign it to a variable or store it in a class member, the\nhandle will be destroyed immediately and the watch will not be called\nwhen the cell values change."]}),(0,t.jsx)(n.p,{children:"Don't do this:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// BAD because the watch handle is destroyed immediately,\n// due to it not being stored anywhere,\n// and thus the watch function is also stopped immediately\nlive_cells::watch([=] {\n\t...\n});\n"})})]}),"\n",(0,t.jsx)(n.h2,{id:"computed-cells",children:"Computed Cells"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.em,{children:"computed cell"})," is a cell with a value that is defined as a function\nof the values of one or more argument cells. Whenever the value of an\nargument cell changes, the value of the computed cell is recomputed."]}),"\n",(0,t.jsxs)(n.p,{children:["Compute cells are defined using ",(0,t.jsx)(n.code,{children:"live_cells::computed"})," which takes the\nvalue computation function of the cell:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Computed cells"',children:"auto a = live_cells::variable(1);\nauto b = live_cells::variable(2)\nauto sum = live_cells::computed([=] {\n    return a() + b()\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the above example, ",(0,t.jsx)(n.code,{children:"sum"})," is a computed cell with the value defined\nas the sum of cells ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"}),". The value of ",(0,t.jsx)(n.code,{children:"sum"})," is recomputed\nwhenever the values of either ",(0,t.jsx)(n.code,{children:"a"})," or ",(0,t.jsx)(n.code,{children:"b"})," change. This is demonstrated\nbelow:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'auto watcher = live_cells::watch([=] {\n    std::cout << "The sum is ";\n    std::cout << sum() << std::endl;\n});\n\na.value(3); // Prints: The sum is 5\nb.value(4); // Prints: The sum is 7\n'})}),"\n",(0,t.jsx)(n.p,{children:"In this example:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["A watch function observing the ",(0,t.jsx)(n.code,{children:"sum"})," cell is defined."]}),"\n",(0,t.jsxs)(n.li,{children:["The value of ",(0,t.jsx)(n.code,{children:"a"})," is set to ",(0,t.jsx)(n.code,{children:"3"}),", which:","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Causes the value of ",(0,t.jsx)(n.code,{children:"sum"})," to be recomputed"]}),"\n",(0,t.jsx)(n.li,{children:"Calls the watch function defined in 1."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["The value of ",(0,t.jsx)(n.code,{children:"b"})," is set to ",(0,t.jsx)(n.code,{children:"4"}),", which likewise also results in the\nsum being recomputed and the watch function being called."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"batch-updates",children:"Batch Updates"}),"\n",(0,t.jsxs)(n.p,{children:["The values of multiple cells can be set simultaneously in a ",(0,t.jsx)(n.em,{children:"batch\nupdate"}),". The effect of this is that while the values of the cells are\nchanged as soon as the ",(0,t.jsx)(n.code,{children:"value()"})," setter method is called, the\nobservers of the cells are only notified after all the cell values\nhave been set."]}),"\n",(0,t.jsxs)(n.p,{children:["Batch updates are performed with ",(0,t.jsx)(n.code,{children:"live_cells:batch"}),", which takes a\nfunction that is called to set the values of one or more cells:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Batch updates"',children:'auto a = live_cells::variable(0);\nauto b = live_cells::variable(1);\n\nauto watcher = live_cells::watch([=] {\n    std::cout << a();\n    std::cout << ", ";\n    std::cout << b();\n});\n\n// This only prints: a = 15, b = 3\nlive_cells::batch([&] {\n    a.value(15);\n    b.value(3);\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In the example above, the values of ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," are set to ",(0,t.jsx)(n.code,{children:"15"})," and\n",(0,t.jsx)(n.code,{children:"3"})," respectively, within a ",(0,t.jsx)(n.code,{children:"live_cells::batch"}),". The watch function,\nwhich observes both ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"}),", is only called once after the values\nof both ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," are set within ",(0,t.jsx)(n.code,{children:"live_cells::batch"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"As a result the following is printed to the console:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"a = 0, b = 1\na = 15, b = 3\n"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"a = 0, b = 1"})," is printed when the watch function is first defined."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"a = 15, b = 3"})," is printed when the function provided to\n",(0,t.jsx)(n.code,{children:"live_cells::watch"})," returns."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"A watch function is always called once immediately after it is set\nup. This is necessary to determine, which cells the watch function is\nobserving."})}),"\n",(0,t.jsxs)(n.p,{children:["Alternatively a batch update can be performed by creating a\n",(0,t.jsx)(n.code,{children:"live_cells::batch_update"})," in a given scope. The batching comes into\neffect when the ",(0,t.jsx)(n.code,{children:"batch_update"})," is created and the cell values are\nupdated when the ",(0,t.jsx)(n.code,{children:"batch_update"})," is destroyed (on leaving the scope)."]}),"\n",(0,t.jsxs)(n.p,{children:["The following is equivalent to the previous example using\n",(0,t.jsx)(n.code,{children:"live_cells::batch"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'auto a = live_cells::variable(0);\nauto b = live_cells::variable(1);\n\nauto watcher = live_cells::watch([=] {\n    std::cout << a();\n    std::cout << ", ";\n    std::cout << b();\n});\n\n{\n    live_cells::batch_update b;\n    \n    a.value(15);\n    b.value(3);\n} // Prints: a = 15, b = 3\n'})}),"\n",(0,t.jsx)(n.h2,{id:"cell-types",children:"Cell Types"}),"\n",(0,t.jsxs)(n.p,{children:["In the examples till this point we've been using ",(0,t.jsx)(n.code,{children:"auto"})," to declare the\nvariables holding our cells. This is because the actual type varies\ndepending on the type of cell (constant cell, mutable cell, computed\ncell, etc.) and also on the parameters used to create the cell. For\nthe type of a computed cell depends on the value computation\nfunction."]}),"\n",(0,t.jsxs)(n.p,{children:["All cell types satisfy the ",(0,t.jsx)(n.code,{children:"live_cells::Cell"})," concept, which specifies\nthe cell protocol. We've already used two methods specified by the\n",(0,t.jsx)(n.code,{children:"Cell"})," concept, the ",(0,t.jsx)(n.code,{children:"value()"})," getter method and the function call\noperator overload."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Mutable cells satisfy the ",(0,t.jsx)(n.code,{children:"live_cells::MutableCell"})," concept, which\nspecifies the mutable cell protocol. ",(0,t.jsx)(n.code,{children:"MutableCell"})," is a superset of\n",(0,t.jsx)(n.code,{children:"Cell"}),", which means that every type that satisfies ",(0,t.jsx)(n.code,{children:"MutableCell"})," also\nsatisfies ",(0,t.jsx)(n.code,{children:"Cell"}),"."]})}),"\n",(0,t.jsxs)(n.p,{children:["To define a function that takes a cell as an argument, define the a\nfunction ",(0,t.jsx)(n.code,{children:"template"})," with the ",(0,t.jsx)(n.code,{children:"Cell"})," concept constrained on the\ntemplate parameter type. For example here's a simple function ",(0,t.jsx)(n.code,{children:"add"}),",\nwhich takes two cells and returns a computed cell that computes the\nsum of the two cells:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Cells in functions"',children:"template <live_cells::Cell A, live_cells::Cell B>\nauto add(const A &a, const B &b) {\n    return live_cells::computed([=] {\n        return a() + b();\n    });\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This ensures that only an object that implements the cell protocol can\nbe provided for ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The definition of the ",(0,t.jsx)(n.code,{children:"add"})," function can be simplified using C++20's template\nshorthand syntax:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"auto add (const Cell auto &a, const Cell auto &b) {\n    return live_cells::computed([=] {\n        return a() + b();\n    });\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"dynamically-typed-cells",children:"Dynamically Typed Cells"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Cell"})," concept and ",(0,t.jsx)(n.code,{children:"auto"})," limits you to cells for which the exact\ntype is known at compile-time. This means you cannot use them to store\ncells of unrelated, and unknown, types in a container such as\n",(0,t.jsx)(n.code,{children:"std::vector"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["For this use case, the ",(0,t.jsx)(n.code,{children:"live_cells::cell"})," wrapper is provided. ",(0,t.jsx)(n.code,{children:"cell"}),"\nis a wrapper over a ",(0,t.jsx)(n.code,{children:"Cell"})," that performs type erasure, much like\n",(0,t.jsx)(n.code,{children:"std::function"}),", in which a cell of any type can be stored."]}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"cell"})," wrapper is created by providing a ",(0,t.jsx)(n.code,{children:"Cell"})," to its\nconstructor. The wrapper exposes the same methods specified by the\n",(0,t.jsx)(n.code,{children:"Cell"})," concept however the ",(0,t.jsx)(n.code,{children:"value()"})," getter method is a template that\nhas to be invoked with a type parameter, specifying the type of value\nto retrieve:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Dynamically Typed Cells"',children:"// A vector that can hold cells of any type\nstd::vector<live_cells::cell> my_cells;\n\n// A statically typed mutable cell\nauto a = live_cells::variable(0);\n\n// A dynamically typed cell\nlive_cells::cell ref_a(a);\n\n// `ref_a` can be added to a vector whereas `a` cannot\nmy_cells.push_back(ref_a);\n\n// Printing the value of `a` via the `cell` wrapper:\n\n// Prints: 0\nstd::cout << ref_a.value<int>() << std::endl;\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["The template type parameter provided to ",(0,t.jsx)(n.code,{children:"value"})," has to match the type\nof the value held in the cell exactly, otherwise an ",(0,t.jsx)(n.code,{children:"std::bad_cast"}),"\nexception is thrown."]})}),"\n",(0,t.jsxs)(n.p,{children:["When the value type of the value held in the cell is known ahead of\ntime, the ",(0,t.jsx)(n.code,{children:"typed_cell"})," wrapper can be used which is the same as ",(0,t.jsx)(n.code,{children:"cell"}),"\nbut takes the value type as a template parameter:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Dynamic Cell Type with Static Value Type"',children:"// A vector that can hold cells of any type that hold an `int`\nstd::vector<live_cells::typed_cell<int>> my_cells;\n\n// A statically typed mutable cell\nauto a = live_cells::variable(0);\n\n// A dynamically typed cell\nlive_cells::typed_cell<int> ref_a(a);\n\n// `ref_a` can be added to a vector whereas `a` cannot\nmy_cells.push_back(ref_a);\n\n// Prints: 0\nstd::cout << ref_a.value() << std::endl;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Notice there is no need to provided a value type template parameter to\nthe ",(0,t.jsx)(n.code,{children:"value()"})," method, because the value type (",(0,t.jsx)(n.code,{children:"int"})," in this case) is\ngiven in the ",(0,t.jsx)(n.code,{children:"typed_cell"})," template parameter."]}),"\n",(0,t.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,t.jsx)(n.p,{children:"Cells mostly take care of their own memory management, but there are a\nfew points to keep in mind when using cells:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"A cell holds a reference to its state. This means, copying a cell\ndoes not copy the underlying state but merely creates a new\nreference to it:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"auto a = live_cells::variable(0);\nauto b = a;\n\na.value(10);\n\n// Prints: 10\nstd::cout << b.value() << std::endl;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["That's why, as you've probably noticed, the lambda functions\nprovided to ",(0,t.jsx)(n.code,{children:"live_cells::watch"})," and ",(0,t.jsx)(n.code,{children:"live_cells::computed"})," capture\ntheir cells by value, not reference."]}),"\n",(0,t.jsx)(n.p,{children:"The cell state holds the cell's value and its observers."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"If a lambda function can escape its scope, capture cells by value\nnot by reference."}),"\n",(0,t.jsxs)(n.p,{children:["Both ",(0,t.jsx)(n.code,{children:"live_cells::watch"})," and ",(0,t.jsx)(n.code,{children:"live_cells::computed"})," store a copy of\nthe lambda which can potentially long outline the scope in which\nthe lambda function is defined. If a cell is captured by reference\nin this case, it end up as a dangling reference."]}),"\n",(0,t.jsxs)(n.p,{children:["On the other hand, ",(0,t.jsx)(n.code,{children:"live_cells::batch"})," does not copy or store the\nfunction provided to it but only calls it immediately. Thus it is\nsafe to use capture by reference in this case. However, when in\ndoubt capture by value."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"The state of a cell is destroyed when the last cell referencing the\nstate is destroyed."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"auto a = live_cells::variable(0);\nlive_cells::cell ref(a);\n\n{ // Create a new scope\n    auto b = live_cells::variable(1);\n    auto c = live_cells::variable(2);\n\n    // Set `ref` to `b`\n    ref = live_cells::cell(b);\n} // Th state of `c` is destroyed at this point\n\n// The state of `b` is not destroyed because `ref`\n// is still holding a reference to it\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this regard cells function much like ",(0,t.jsx)(n.code,{children:"std::shared_ptr"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Do not wrap a cell in ",(0,t.jsx)(n.code,{children:"std::shared_ptr"}),". Whilst not wrong, its\nunnecessary because cells are already a form of shared pointer to\ntheir underlying state. Therefore, it's best to simply copy the\ncell, whether statically or dynamically typed."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Mutable cell values are assigned by value, not by reference. This\nprobably goes without saying but its best to state it explicitly"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'auto a = live_cells::variable(std::string("hello"));\n\n// The string "bye" is copied into the `std::string` held by\n// the cell.\na.value("bye");\n'})}),"\n"]}),"\n"]})]})}function r(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>a,x:()=>i});var t=l(6540);const s={},c=t.createContext(s);function a(e){const n=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);