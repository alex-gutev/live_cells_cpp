"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[553],{7512:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>r});var t=l(4848),s=l(8453);const i={title:"Cell Expressions",description:"Creating cells using expressions",sidebar_position:2},c="Cell Expressions",a={id:"basics/cell-expressions",title:"Cell Expressions",description:"Creating cells using expressions",source:"@site/docs/basics/cell-expressions.md",sourceDirName:"basics",slug:"/basics/cell-expressions",permalink:"/live_cells_cpp/docs/basics/cell-expressions",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Cell Expressions",description:"Creating cells using expressions",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Cells",permalink:"/live_cells_cpp/docs/basics/cells"},next:{title:"Two-way Data Flow",permalink:"/live_cells_cpp/docs/basics/two-way-data-flow"}},o={},r=[{value:"Arithmetic",id:"arithmetic",level:2},{value:"Equality",id:"equality",level:2},{value:"Logic and selection",id:"logic-and-selection",level:2},{value:"Aborting a computation",id:"aborting-a-computation",level:2},{value:"Exception Handling",id:"exception-handling",level:2},{value:"Peeking Cells",id:"peeking-cells",level:2}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"cell-expressions",children:"Cell Expressions"}),"\n",(0,t.jsxs)(n.p,{children:["This library provides a number of tools for building expressions of\ncells without requiring a computed cell to be created explicitly using\n",(0,t.jsx)(n.code,{children:"live_cells::computed"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"arithmetic",children:"Arithmetic"}),"\n",(0,t.jsxs)(n.p,{children:["The arithmetic and relational (",(0,t.jsx)(n.code,{children:"<"}),", ",(0,t.jsx)(n.code,{children:"<="}),", ",(0,t.jsx)(n.code,{children:">"}),", ",(0,t.jsx)(n.code,{children:">="}),") operators, when\napplied to cells holding numeric values, return cells which compute the\nresult of the expression."]}),"\n",(0,t.jsx)(n.p,{children:"This allows a computation to be defined directly as an expression of\ncells. For example the following cell computes the sum of two cells:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Arithmetic Expressions"',children:"auto a = live_cells::variable(1);\nauto b = live_cells::variable(2);\n\nauto sum = a + b;\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["This definition of the sum cell is not only simpler than the\ndefinition using ",(0,t.jsx)(n.code,{children:"live_cells::computed"})," but is also more efficient\nsince the argument cells are determined at compile-time."]})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"sum"})," cell is a cell like any other. It can be observed by a watch\nfunction or can appear as an argument in a computed cell."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Observing expression cells"',children:"auto watcher = live_cells::watch([=] {\n    std::cout << sum() << std::endl;\n});\n\na.value(5); // Prints: 7\nb.value(4); // Prints: 9\n"})}),"\n",(0,t.jsx)(n.p,{children:"Expressions of cells can be arbitrarily complex:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Complex Cell Expressions"',children:"auto x = a * b + c / d;\nauto y = x < e;\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["To include a constant in a cell expression wrap it in a cell using\n",(0,t.jsx)(n.code,{children:"live_cells::value"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"equality",children:"Equality"}),"\n",(0,t.jsxs)(n.p,{children:["Every cell overloads the ",(0,t.jsx)(n.code,{children:"=="})," and ",(0,t.jsx)(n.code,{children:"!="})," operators, which returns cells\nthat compare whether the values of the cells are equal or not equal,\nrespectively."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Equality Comparison"',children:"auto eq = a == b;  // eq() == true when a() == b()\nauto neq = a != b; // neq() == true when a() != b()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"logic-and-selection",children:"Logic and selection"}),"\n",(0,t.jsx)(n.p,{children:"The following operator overloads and functions are provided for cells\nholding boolean-like value:"}),"\n",(0,t.jsxs)("dl",{children:[(0,t.jsx)("dt",{children:(0,t.jsx)(n.code,{children:"&&"})}),(0,t.jsx)("dd",{children:"Creates a cell with a value that is the logical and of two cells"}),(0,t.jsx)("dt",{children:(0,t.jsx)(n.code,{children:"||"})}),(0,t.jsx)("dd",{children:"Creates a cell with a value that is the logical or of two cells"}),(0,t.jsx)("dt",{children:(0,t.jsx)(n.code,{children:"!"})}),(0,t.jsx)("dd",{children:"Creates a cell with a value which is the logical not of a cell"}),(0,t.jsx)("dt",{children:(0,t.jsx)(n.code,{children:"select"})}),(0,t.jsx)("dd",{children:"Creates a cell which selects between the values of two cells based on a condition"})]}),"\n",(0,t.jsx)(n.admonition,{type:"important",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"&&"})," and ",(0,t.jsx)(n.code,{children:"||"})," operators overloads preserve the short-circuiting\nbehaviour of the operators. This means the value of a cell is not\nreferenced if the result of the expression is already known without\nit."]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Logic and selection expressions"',children:"// cond() is true when a() || b() is true\nauto cond = a || b;\n\n// when cond() is true, cell() == c() else cell() == d()\nauto cell = live_cells::select(cond, c, d);\n\na.value(true);\nc.value(1);\nd.value(2);\n\nstd::cout << cell.value() << std::endl; // Prints: 1\n\na.value(false);\nb.value(false);\n\nstd::cout << cell.value() << std::endl; // Prints: 2\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The third argument (if false) of ",(0,t.jsx)(n.code,{children:"select"})," can be omitted, in which case\nthe cell's value will not be updated if the condition is false:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Single argument select"',children:"auto cell = live_cells::select(cond, c);\n\ncond.value(true);\na.value(2);\n\nstd::cout << cell.value() << std::endl; // Prints 2\n\ncond.value(false);\na.value(4);\n\nstd::cout << cell.value() << std::endl; // Prints 2\n"})}),"\n",(0,t.jsx)(n.h2,{id:"aborting-a-computation",children:"Aborting a computation"}),"\n",(0,t.jsxs)(n.p,{children:["In the previous section we saw that the ",(0,t.jsx)(n.code,{children:"select"})," method creates a cell\nwhich does not update its argument when the condition cell is ",(0,t.jsx)(n.code,{children:"false"}),"\nand its only given one argument. Under the hood, ",(0,t.jsx)(n.code,{children:"select"})," isn't some\nspecial kind of cell but uses ",(0,t.jsx)(n.code,{children:"live_cells::none()"})," to abort the\ncomputation."]}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"live_cells::none()"})," is called inside a computed cell, the\ncomputation of the cell's value is aborted and its current value is\npreserved. This can be used to prevent a cell's value from being\nrecomputed when a condition is not met:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Example of ValueCell.none()"',children:"auto a = live_cells::variable(4);\nauto b = live_cells::computed([=] {\n    if (a() >= 10)\n        live_cells::none();\n        \n    return a();\n});\n\na.value(6);\nstd::cout << b.value() << std::endl; // Prints 6\n\na.value(15);\nstd::cout << b.value() << std::endl; // Prints 6\n\na.value(8);\nstd::cout << b.value() << std::endl; // Prints 8\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["The initial value of every computed cell is the default constructed\nvalue. Thus if ",(0,t.jsx)(n.code,{children:"live_cells::none()"})," is called during the first call to\nthe cell's computation function, the default value for the cell's\nvalue type is retained."]})}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["The value of a computed cell is only computed if it is actually\nreferenced. ",(0,t.jsx)(n.code,{children:"live_cells::none()"})," only preserves the current value of\nthe cell, but this might not be the latest value of the cell if the\ncell's value is only referenced conditionally. A good rule of thumb is\nto use ",(0,t.jsx)(n.code,{children:"live_cells::none()"})," only to prevent a cell from holding an\ninvalid value."]})}),"\n",(0,t.jsx)(n.h2,{id:"exception-handling",children:"Exception Handling"}),"\n",(0,t.jsxs)(n.p,{children:["If an exception is thrown during the computation of a cell's value it\nis rethrown when the value is referenced. This allows exceptions to be\nhandled using ",(0,t.jsx)(n.code,{children:"try"})," and ",(0,t.jsx)(n.code,{children:"catch"})," inside computed cells:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Exception handling in computed cells"',children:'auto str = live_cells::variable(std::string("0"));\n\nauto n = live_cells::computed([=] {\n    return std::stoi(str());\n});\n\nauto is_valid = live_cells::computed([=] {\n  try {\n    return n() > 0;\n  }\n  catch (...) {\n    return false;\n  }\n});\n\nstd::cout << is_valid.value() << std::endl; // Prints false\n\nstr.value = "5";\nstd::cout << is_valid.value() << std::endl; // Prints true\n\nstr.value = "not a number";\nstd::cout << is_valid.value() << std::endl; // Prints false\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"on_error"})," function creates a cell that selects the value of another\ncell when an exception is thrown."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Example of onError"',children:'auto str = live_cells::variable(std::string("0"));\n\nauto m = live_cells::variable(2);\nauto n = live_cells::computed([=] {\n    return std::stoi(str());\n});\n\n// Equal to n(). If n() throws, equal to m();\nauto result = live_cells::on_error(n, m);\n\nstr.value("3");\nstd::cout << result.value() << std::endl; // Prints 3\n\nstr.value("not a number");\nstd::cout << result.value() << std::endl; // Prints 2\n'})}),"\n",(0,t.jsxs)(n.p,{children:["A template overload of ",(0,t.jsx)(n.code,{children:"on_error"})," is provided, which takes an\nexception type as a template type parameter. When this overload is\nused only exceptions of the given type are handled."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Handling specific exceptions with onError"',children:" // Only handles std::invalid_argument exceptions\nauto result = on_error<std::invalid_argument>(n, m);\n"})}),"\n",(0,t.jsx)(n.p,{children:"The validation logic in the previous example can be implemented more\nsuccinctly using:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Putting it all together"',children:'auto str = live_cells::variable("0");\nauto n = live_cells::computed([=] {\n    return std::stoi(str());\n});\n\nauto isValid = on_error(\n    n > live_cells::value(0),\n    live_cells::value(false)\n);\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["We used ",(0,t.jsx)(n.code,{children:"live_cells::value(0)"})," and ",(0,t.jsx)(n.code,{children:"live_cells::value(false)"})," to\ncreate constant cells that hold the values ",(0,t.jsx)(n.code,{children:"0"})," and ",(0,t.jsx)(n.code,{children:"false"}),",\nrespectively."]})}),"\n",(0,t.jsx)(n.h2,{id:"peeking-cells",children:"Peeking Cells"}),"\n",(0,t.jsxs)(n.p,{children:["What if you want to use the value of a cell in a computed cell but\ndon't want changes to that cell's value triggering a recomputation?\nThe ",(0,t.jsx)(n.code,{children:"live_cells::peek"})," function allows you to do exactly that."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Example of .peek"',children:"auto a = live_cells::variable(0);\nauto b = live_cells::variable(1);\n\nauto c = live_cells::computed([=] {\n    return a() + live_cells::peek(b);\n});\n\nauto watch = live_cells::watch([=] {\n    std::cout << c() << std::endl;\n});\n\na.value(3); // Prints: 4\nb.value(5); // Doesn't print anything\na.value(7); // Prints: 13\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the above example cell ",(0,t.jsx)(n.code,{children:"c"})," is a computed cell referencing the value\nof ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.em,{children:"peeks"})," the value of ",(0,t.jsx)(n.code,{children:"b"}),". Changing the value of ",(0,t.jsx)(n.code,{children:"a"}),"\ntriggers a recomputation of ",(0,t.jsx)(n.code,{children:"c"}),", and hence triggers the watch function\nwhich prints to the console, but changing the value of ",(0,t.jsx)(n.code,{children:"b"})," doesn't\ntrigger a recomputation of ",(0,t.jsx)(n.code,{children:"c"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"live_cells::peek"})," returns a cell."]})}),"\n",(0,t.jsxs)(n.p,{children:["You may be asking why do we need ",(0,t.jsx)(n.code,{children:"live_cells::peek"})," here instead of\njust accessing the value of ",(0,t.jsx)(n.code,{children:"b"})," directly using ",(0,t.jsx)(n.code,{children:"b.value()"}),". Something\nwe've glossed over till this point is the lifecycle of cells. Cells\nare only active while they are actually observed, and are activated\nwhen the first observer is added. While active, cells react to changes\nin their argument cells. When the last observer is removed, cells are\ndeactivated and stop observing their argument cells. When a new\nobserver is added, they are reactivated again. Essentially, this means\nthat the value of a cell may no longer be current if it doesn't have\nat least one observer. For a computed cell this is not a problem,\nsince when it is inactive it computes its value on demand, but it may\ncause issues with other cells. The ",(0,t.jsx)(n.code,{children:"live_cells::peek"})," function takes\ncare of adding an observer to the peeked cell, so that it remains\nactive, but at the same time prevents the observers, added through\n",(0,t.jsx)(n.code,{children:"live_cells::peek"}),", from being notified of changes in its value."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>c,x:()=>a});var t=l(6540);const s={},i=t.createContext(s);function c(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);