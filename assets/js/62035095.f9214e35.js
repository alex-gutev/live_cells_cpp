"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[809],{7358:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>r});var l=n(4848),s=n(8453);const a={title:"Two-way Data Flow",description:"Introduction on bi-directional data flow",sidebar_position:3},c="Two-Way Data Flow",i={id:"basics/two-way-data-flow",title:"Two-way Data Flow",description:"Introduction on bi-directional data flow",source:"@site/docs/basics/two-way-data-flow.md",sourceDirName:"basics",slug:"/basics/two-way-data-flow",permalink:"/docs/basics/two-way-data-flow",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Two-way Data Flow",description:"Introduction on bi-directional data flow",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Cell Expressions",permalink:"/docs/basics/cell-expressions"}},o={},r=[{value:"Mutable Computed Cells",id:"mutable-computed-cells",level:2},{value:"Multiple Arguments",id:"multiple-arguments",level:2}];function d(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.h1,{id:"two-way-data-flow",children:"Two-Way Data Flow"}),"\n",(0,l.jsx)(t.p,{children:"In all the examples we've seen till this point, data always flows in a\nsingle direction. Now we'll introduce two-way data flow which allows\ndata to flow in both directions between a pair of cells."}),"\n",(0,l.jsx)(t.h2,{id:"mutable-computed-cells",children:"Mutable Computed Cells"}),"\n",(0,l.jsxs)(t.p,{children:["A ",(0,l.jsx)(t.em,{children:"mutable computed cell"})," is a cell which ordinarily functions like a\nnormal computed cell, created with ",(0,l.jsx)(t.code,{children:"live_cells::computed"}),", but can\nalso have its value set directly as though it is a mutable cell. When\nthe value of a mutable computed cell is set, it ",(0,l.jsx)(t.em,{children:"reverses"})," the\ncomputation by setting the argument cells to a value such that when\nthe mutable computed cell is recomputed, the same value will be\nproduced as the value that was set. Thus mutable computed cells\nsupport two-way data flow, which is what sets ",(0,l.jsx)(t.strong,{children:"Live Cells"})," apart\nfrom other reactive state management libraries."]}),"\n",(0,l.jsxs)(t.p,{children:["Mutable computed cells are created using\n",(0,l.jsx)(t.code,{children:"live_cells::mutable_computed"}),", which takes the computation function\nand reverse computation function. The computation function computes\nthe cell's value as a function of argument cells, like\n",(0,l.jsx)(t.code,{children:"live_cells::computed"}),". The reverse computation function ",(0,l.jsx)(t.em,{children:"reverses"}),"\nthe computation by assigning a value to the argument cells. It is\ngiven the value that the cell was assigned to cell."]}),"\n",(0,l.jsx)(t.p,{children:"Example:"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-cpp",metastring:'title="Mutable computed cell example"',children:"auto a = live_cells::variable(0);\n\nauto str_a = live_cells::mutable_computed([=] {\n    return std::to_string(a())\n}, [=] (value) {\n  a.value(std::stoi(value));\n});\n"})}),"\n",(0,l.jsxs)(t.p,{children:["The mutable computed cell ",(0,l.jsx)(t.code,{children:"str_a"})," converts the value of its argument\ncell ",(0,l.jsx)(t.code,{children:"a"})," to a string. When the value of ",(0,l.jsx)(t.code,{children:"str_a"})," is set:"]}),"\n",(0,l.jsxs)(t.ol,{children:["\n",(0,l.jsxs)(t.li,{children:["An ",(0,l.jsx)(t.code,{children:"int"})," is parsed from the value."]}),"\n",(0,l.jsxs)(t.li,{children:["The value of ",(0,l.jsx)(t.code,{children:"a"})," is set to the parsed ",(0,l.jsx)(t.code,{children:"int"})," value."]}),"\n"]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-cpp",metastring:'title="Mutable computed cell"',children:"str_a.value('100');\nstd::cout << (a.value() + 1) << std::endl; // Prints: 101\n"})}),"\n",(0,l.jsxs)(t.p,{children:["This definition is useful for obtaining string input from the user and\nconverting it to an integer. The string input, can be assigned\ndirectly to the ",(0,l.jsx)(t.code,{children:"str_a"})," cell, and the parsed integer can be observed\nby observing ",(0,l.jsx)(t.code,{children:"a"}),"."]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-cpp",children:"auto watcher = live_cells::watch([=] {\n    std::cout << (a.value() + 1) << std::endl;\n});\n\n// Prints: 16\nstr_a.value(15);\n"})}),"\n",(0,l.jsxs)(t.p,{children:["The value of this is that data can also flow from ",(0,l.jsx)(t.code,{children:"a"})," to ",(0,l.jsx)(t.code,{children:"str_a"}),":"]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-cpp",children:"auto watcher = live_cells::watch([=] {\n    std::cout << str_a.value() << std::endl;\n});\n\n// Prints: 7\na.value(7);\n"})}),"\n",(0,l.jsx)(t.h2,{id:"multiple-arguments",children:"Multiple Arguments"}),"\n",(0,l.jsxs)(t.p,{children:["Mutable computed cells can be defined as a function of more than one\nargument cell. For example we can define a ",(0,l.jsx)(t.code,{children:"sum"})," cell, that ordinarily\ncomputes the sum of two numbers held in cells ",(0,l.jsx)(t.code,{children:"a"})," and ",(0,l.jsx)(t.code,{children:"b"}),". When ",(0,l.jsx)(t.code,{children:"sum"}),"\nis assigned a value, ",(0,l.jsx)(t.code,{children:"a"})," and ",(0,l.jsx)(t.code,{children:"b"})," are set to one half of the sum that\nwas assigned."]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-cpp",metastring:'title="Multi-argument mutable computed cell"',children:"auto a = live_cells::variable(0.0);\nauto b = live_cells::variable(0.0);\n\nauto sum = live_cells::mutable_computed([=] {\n    return a() + b();\n}, [=] (sum) {\n    auto half = sum / 2;\n\n    a.value(half);\n    b.value(half);\n});\n"})}),"\n",(0,l.jsxs)(t.p,{children:["The reverse computation function assigns the sum divided by two to\nboth cells ",(0,l.jsx)(t.code,{children:"a"})," and ",(0,l.jsx)(t.code,{children:"b"}),"."]}),"\n",(0,l.jsxs)(t.p,{children:["For example setting ",(0,l.jsx)(t.code,{children:"sum"})," to ",(0,l.jsx)(t.code,{children:"6"})," results in ",(0,l.jsx)(t.code,{children:"a"})," and ",(0,l.jsx)(t.code,{children:"b"})," both being set\nto ",(0,l.jsx)(t.code,{children:"3"}),":"]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-cpp",children:'auto watcher = live_cells::watch([=] {\n    std::cout << a() << " + " << b();\n    std::cout << " = " << sum() << std::endl;\n});\n\n// Prints: 3 + 3 = 6\nsum.value(6);\n'})}),"\n",(0,l.jsxs)(t.p,{children:["The value of ",(0,l.jsx)(t.code,{children:"a"})," and ",(0,l.jsx)(t.code,{children:"b"})," can still be set in which case, ",(0,l.jsx)(t.code,{children:"sum"}),"\ncomputes the sum of the values that were set:"]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-cpp",children:"// Prints: 4 + 3 =7\na.value(4);\n\n// Prints: 4 + 10 = 14\nb.value(10);\n"})})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>i});var l=n(6540);const s={},a=l.createContext(s);function c(e){const t=l.useContext(a);return l.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),l.createElement(a.Provider,{value:t},e.children)}}}]);