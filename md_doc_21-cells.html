<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Live Cells C++: 1. Cells</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Live Cells C++
   </div>
   <div id="projectbrief">Reactive Programming for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_doc_21-cells.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">1. Cells</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> A cell is an object with a value and a set of observers that react to changes in its value, you'll see exactly what that means in a moment.</p>
<p>There are a number of ways to create cells. The simplest cell is the constant cell, created with <code><a class="el" href="namespacelive__cells.html#a163ced4b8bef0f870be26c0a1e8c4c59">live_cells::value()</a></code>, which holds a constant value.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#a163ced4b8bef0f870be26c0a1e8c4c59">live_cells::value</a>(1);</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_class" href="classlive__cells_1_1dynamic__compute__cell.html">live_cells::value&lt;std::string&gt;</a>(<span class="stringliteral">&quot;hello world&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> c = <a class="code hl_function" href="namespacelive__cells.html#a163ced4b8bef0f870be26c0a1e8c4c59">live_cells::value</a>(some_value);</div>
<div class="ttc" id="aclasslive__cells_1_1dynamic__compute__cell_html"><div class="ttname"><a href="classlive__cells_1_1dynamic__compute__cell.html">live_cells::dynamic_compute_cell</a></div><div class="ttdoc">A computed cell which determines its argument cells at runtime.</div><div class="ttdef"><b>Definition</b> dynamic_compute_cell.hpp:136</div></div>
<div class="ttc" id="anamespacelive__cells_html_a163ced4b8bef0f870be26c0a1e8c4c59"><div class="ttname"><a href="namespacelive__cells.html#a163ced4b8bef0f870be26c0a1e8c4c59">live_cells::value</a></div><div class="ttdeci">constant_cell&lt; T &gt; value(const T &amp;value)</div><div class="ttdef"><b>Definition</b> constant_cell.hpp:132</div></div>
</div><!-- fragment --><p><code><a class="el" href="namespacelive__cells.html#a163ced4b8bef0f870be26c0a1e8c4c59">live_cells::value()</a></code> takes the constant value and wraps it in a constant cell. The values of constant cells never change.</p>
<p>The value of a cell is accessed using the <a class="el" href="classlive__cells_1_1constant__cell.html#a76c1cd346565bd3eeebfa19db6c06457"><code>value()</code></a> accessor method.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; a.value() &lt;&lt; std::endl; <span class="comment">// Prints: 1</span></div>
<div class="line">std::cout &lt;&lt; b.value() &lt;&lt; std::endl; <span class="comment">// Prints: &#39;hello world&#39;</span></div>
<div class="line">std::cout &lt;&lt; c.value() &lt;&lt; std::endl; <span class="comment">// Prints the value of `someValue`</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1"></a>
Mutable Cells</h1>
<p>Mutable cells, created with <code><a class="el" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3" title="Create a new mutable cell with an initial value.">live_cells::variable()</a></code>, which takes the initial value of the cell, hold a value that can be set with the <code>value()</code> setter method, which takes the new value.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(0);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; a.value() &lt;&lt; std::endl; <span class="comment">// Prints: 0</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the value of a to 3</span></div>
<div class="line">a.value(3);</div>
<div class="line">std::cout &lt;&lt; a.value() &lt;&lt; std::endl; <span class="comment">// Prints: 3</span></div>
<div class="ttc" id="anamespacelive__cells_html_ab365650aeb27f61f31622a49d4fb79a3"><div class="ttname"><a href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a></div><div class="ttdeci">mutable_cell&lt; T &gt; variable(T value)</div><div class="ttdoc">Create a new mutable cell with an initial value.</div><div class="ttdef"><b>Definition</b> mutable_cell.hpp:276</div></div>
</div><!-- fragment --><p>The value of a mutable cell can also be set with the assignment <code>=</code> operator:</p>
<div class="fragment"><div class="line"><span class="comment">// Set the value of a to 3</span></div>
<div class="line">a = 3;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2"></a>
Observing Cells</h1>
<p>When the value of a cell changes, its observers are notified of the change. The simplest way to demonstrate this is to set up a <em>watch function</em> using <code><a class="el" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87" title="Register a cell watch function.">live_cells::watch()</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(0);</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set up a watch function observing cells `a` and `b`</span></div>
<div class="line"><span class="keyword">auto</span> watcher = <a class="code hl_function" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87">live_cells::watch</a>([=] {</div>
<div class="line">    std::cout &lt;&lt; a();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; b();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">a = 5;  <span class="comment">// Prints: 5, 1</span></div>
<div class="line">b = 10; <span class="comment">// Prints: 5, 10</span></div>
<div class="ttc" id="anamespacelive__cells_html_aff827bee503738afea0d4de923ca0e87"><div class="ttname"><a href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87">live_cells::watch</a></div><div class="ttdeci">std::shared_ptr&lt; watcher &gt; watch(F fn)</div><div class="ttdoc">Register a cell watch function.</div><div class="ttdef"><b>Definition</b> watcher.hpp:193</div></div>
</div><!-- fragment --><p><code><a class="el" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87" title="Register a cell watch function.">live_cells::watch()</a></code> takes a watch function and registers it to be called when the values of the cells referenced within it change. In the example above, a watch function that prints the values of cells <code>a</code> and <code>b</code> to standard output, is defined. This function is called automatically when the value of either <code>a</code> or <code>b</code> changes.</p>
<p>There are a couple of important points to keep in mind when using <code><a class="el" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87" title="Register a cell watch function.">live_cells::watch()</a></code>:</p>
<ul>
<li>The watch function is called once immediately when <code><a class="el" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87" title="Register a cell watch function.">live_cells::watch()</a></code> is called, to determine which cells are referenced by it.</li>
<li><code><a class="el" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87" title="Register a cell watch function.">live_cells::watch()</a></code> automatically tracks which cells are referenced within it, and registers it to be called when their values change. This works even when the cells are referenced conditionally.</li>
<li>Within the watch function, the values of cells have to be referenced with the function call operator, rather than the <code>value()</code> method. The difference between the two is that <code>value()</code> only references the value, whereas the function call operator also tracks it as a referenced cell.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Within a watch function, the value of a cell is referenced using the function call syntax rather than the <code>value()</code> method.</dd></dl>
<p>Every call to <code><a class="el" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87" title="Register a cell watch function.">live_cells::watch()</a></code> adds a new watch function, for example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> watcher2 = <a class="code hl_function" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87">live_cells::watch</a>([=] {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;A = &quot;</span> &lt;&lt; a() &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prints: 20, 10</span></div>
<div class="line"><span class="comment">// Also prints: A = 20</span></div>
<div class="line">a = 20;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prints: 20, 1</span></div>
<div class="line">b = 1;</div>
</div><!-- fragment --><p>The watch function defined above, <code>watcher2</code>, observes the value of <code>a</code> only. Changing the value of <code>a</code> results in both watch functions being called. Changing the value of <code>b</code> only results in the first watch function being called, since the second watch function does not reference <code>b</code> and hence is not observing it.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When you no longer need the watch function to be called, call <a class="el" href="classlive__cells_1_1watcher.html#a3b7a6c9470f758750be13a603d16584c"><code>stop()</code></a> on the "handle" returned by <code><a class="el" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87" title="Register a cell watch function.">live_cells::watch()</a></code><br  />
<div class="fragment"><div class="line">watcher1-&gt;stop();</div>
</div><!-- fragment --></dd></dl>
<p><code><a class="el" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87" title="Register a cell watch function.">live_cells::watch()</a></code> returns a shared pointer (<code>std::shared_ptr</code>) holding a handle (<code><a class="el" href="classlive__cells_1_1watcher.html" title="Handle for a cell watch function.">live_cells::watcher</a></code>) to the watch function. This handle provides the <a class="el" href="classlive__cells_1_1watcher.html#a3b7a6c9470f758750be13a603d16584c"><code>stop()</code></a> method, which stops the watch function from being called for further changes in the cell values.</p>
<div class="fragment"><div class="line"><span class="comment">// Prints: 2, 1</span></div>
<div class="line">b = 2;</div>
<div class="line"> </div>
<div class="line">watcher1-&gt;stop();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Doesn&#39;t print anything</span></div>
<div class="line">b = 3;</div>
</div><!-- fragment --><p>The watch function is also stopped automatically when the last <code>shared_ptr</code> point to the handle, is destroyed.</p>
<dl class="section warning"><dt>Warning</dt><dd>Due to the watch function being stopped automatically on destruction, you should always assign the handle returned by <code><a class="el" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87" title="Register a cell watch function.">live_cells::watch()</a></code> to a variable, even if you don't intend on using it directly. If you don't assign it to a variable or store it in a class member, the handle will be destroyed immediately and the watch will not be called when the cell values change.<br  />
<br  />
<b>Don't do this</b>:<br  />
<div class="fragment"><div class="line"><span class="comment">// BAD because the watch handle is destroyed immediately,</span></div>
<div class="line"><span class="comment">// due to it not being stored anywhere,</span></div>
<div class="line"><span class="comment">// and thus the watch function is also stopped immediately</span></div>
<div class="line"><a class="code hl_function" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87">live_cells::watch</a>([=] {</div>
<div class="line">    ...</div>
<div class="line">});</div>
</div><!-- fragment --></dd></dl>
<h1><a class="anchor" id="autotoc_md3"></a>
Computed Cells</h1>
<p>A <em>computed cell</em> is a cell with a value that is defined as a function of the values of one or more argument cells. Whenever the value of an argument cell changes, the value of the computed cell is recomputed.</p>
<p>Computed cells are defined using <code><a class="el" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441" title="Create a cell with a value that is a function of one or more argument cells.">live_cells::computed()</a></code> which takes the value computation function of the cell:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(1);</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(2);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> sum = <a class="code hl_function" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441">live_cells::computed</a>([=] {</div>
<div class="line">    <span class="keywordflow">return</span> a() + b()</div>
<div class="line">});</div>
<div class="ttc" id="anamespacelive__cells_html_a38ef71dbf501d266974a7fae279a8441"><div class="ttname"><a href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441">live_cells::computed</a></div><div class="ttdeci">auto computed(F &amp;&amp;compute)</div><div class="ttdoc">Create a cell with a value that is a function of one or more argument cells.</div><div class="ttdef"><b>Definition</b> computed.hpp:45</div></div>
</div><!-- fragment --><p>In the above example, <code>sum</code> is a computed cell with the value defined as the sum of cells <code>a</code> and <code>b</code>. The value of <code>sum</code> is recomputed whenever the values of either <code>a</code> or <code>b</code> change. This is demonstrated below:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> watcher = <a class="code hl_function" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87">live_cells::watch</a>([=] {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The sum is &quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; sum() &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">a = 3; <span class="comment">// Prints: The sum is 5</span></div>
<div class="line">b = 4; <span class="comment">// Prints: The sum is 7</span></div>
</div><!-- fragment --><p>In this example:</p>
<ol type="1">
<li>A watch function observing the <code>sum</code> cell is defined.</li>
<li>The value of <code>a</code> is set to <code>3</code>, which:<ol type="a">
<li>Causes the value of <code>sum</code> to be recomputed</li>
<li>Calls the watch function defined in 1.</li>
</ol>
</li>
<li>The value of <code>b</code> is set to <code>4</code>, which likewise also results in <code>sum</code> being recomputed and the watch function being called.</li>
</ol>
<h1><a class="anchor" id="autotoc_md4"></a>
Batch Updates</h1>
<p>The values of multiple cells can be set simultaneously in a <em>batch update</em>. The effect of this is that while the values of the cells are changed as soon as the <code>value()</code> setter method, or assignment operator, is called, the observers of the cells are only notified after all the cell values have been set.</p>
<p>Batch updates are performed with <code><a class="el" href="namespacelive__cells.html#a7b04ad09f594427e1650b75047540f80" title="Batch changes to the values of mutable cells.">live_cells::batch()</a></code>, which takes a function that is called to set the values of one or more cells:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(0);</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(1);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> watcher = <a class="code hl_function" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87">live_cells::watch</a>([=] {</div>
<div class="line">    std::cout &lt;&lt; a();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; b();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This only prints: a = 15, b = 3</span></div>
<div class="line"><a class="code hl_function" href="namespacelive__cells.html#a7b04ad09f594427e1650b75047540f80">live_cells::batch</a>([&amp;] {</div>
<div class="line">    a = 15;</div>
<div class="line">    b = 3;</div>
<div class="line">});</div>
<div class="ttc" id="anamespacelive__cells_html_a7b04ad09f594427e1650b75047540f80"><div class="ttname"><a href="namespacelive__cells.html#a7b04ad09f594427e1650b75047540f80">live_cells::batch</a></div><div class="ttdeci">void batch(F fn)</div><div class="ttdoc">Batch changes to the values of mutable cells.</div><div class="ttdef"><b>Definition</b> mutable_cell.hpp:307</div></div>
</div><!-- fragment --><p>In the example above, the values of <code>a</code> and <code>b</code> are set to <code>15</code> and <code>3</code> respectively, within <code><a class="el" href="namespacelive__cells.html#a7b04ad09f594427e1650b75047540f80" title="Batch changes to the values of mutable cells.">live_cells::batch()</a></code>. The watch function, which observes both <code>a</code> and <code>b</code>, is only called once after the values of both <code>a</code> and <code>b</code> are set.</p>
<p>As a result the following is printed to the console:</p>
<div class="fragment"><div class="line">a = 0, b = 1</div>
<div class="line">a = 15, b = 3</div>
</div><!-- fragment --><ol type="1">
<li><code>a = 0, b = 1</code> is printed when the watch function is first defined.</li>
<li><code>a = 15, b = 3</code> is printed when the function provided to <code><a class="el" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87" title="Register a cell watch function.">live_cells::watch()</a></code> returns.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>A watch function is always called once immediately after it is set up. This is necessary to determine which cells the watch function is observing.</dd></dl>
<p>Alternatively a batch update can be performed by creating a <code><a class="el" href="classlive__cells_1_1batch__update.html" title="Defer changes to the values of mutable cells.">live_cells::batch_update</a></code> in a given scope. The batching comes into effect when the <code>batch_update</code> is created and the cell values are updated when the <code>batch_update</code> is destroyed (on leaving the scope).</p>
<p>The following is equivalent to the previous example using <code><a class="el" href="namespacelive__cells.html#a7b04ad09f594427e1650b75047540f80" title="Batch changes to the values of mutable cells.">live_cells::batch()</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(0);</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(1);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> watcher = <a class="code hl_function" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87">live_cells::watch</a>([=] {</div>
<div class="line">    std::cout &lt;&lt; a();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; b();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classlive__cells_1_1batch__update.html">live_cells::batch_update</a> b;</div>
<div class="line">    </div>
<div class="line">    a = 15;</div>
<div class="line">    b = 3;</div>
<div class="line">} <span class="comment">// Prints: a = 15, b = 3</span></div>
<div class="ttc" id="aclasslive__cells_1_1batch__update_html"><div class="ttname"><a href="classlive__cells_1_1batch__update.html">live_cells::batch_update</a></div><div class="ttdoc">Defer changes to the values of mutable cells.</div><div class="ttdef"><b>Definition</b> mutable_cell.hpp:44</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5"></a>
Cell Types</h1>
<p>In the examples till this point we've been using <code>auto</code> to declare the variables holding our cells. This is because the actual type varies depending on the type of cell (constant cell, mutable cell, computed cell, etc.) and also on the parameters used to create the cell. For example, the type of a computed cell depends on the value computation function.</p>
<p>All cell types satisfy the <code><a class="el" href="conceptlive__cells_1_1Cell.html" title="Defines the cell protocol.">live_cells::Cell</a></code> concept, which specifies the cell protocol. We've already used two methods specified by the <code>Cell</code> concept, the <code>value()</code> getter method and the function call operator overload.</p>
<dl class="section note"><dt>Note</dt><dd>Mutable cells satisfy the <code><a class="el" href="conceptlive__cells_1_1MutableCell.html" title="Concept defining a Cell that can have its value set.">live_cells::MutableCell</a></code> concept, which specifies the mutable cell protocol. <code>MutableCell</code> is a superset of <code>Cell</code>, which means that every type that satisfies <code>MutableCell</code> also satisfies <code>Cell</code>.</dd></dl>
<p>To define a function that takes a cell as an argument, define a function <code>template</code> with the template parameters constrained by the <code>Cell</code> concept. For example here's a simple function <code>add</code>, which takes two cells and returns a computed cell that computes the sum of the two cells:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;live_cells::Cell A, live_cells::Cell B&gt;</div>
<div class="line"><span class="keyword">auto</span> add(<span class="keyword">const</span> A &amp;a, <span class="keyword">const</span> B &amp;b) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441">live_cells::computed</a>([=] {</div>
<div class="line">        <span class="keywordflow">return</span> a() + b();</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><p>This ensures that only an object that implements the cell protocol can be provided for <code>a</code> and <code>b</code>.</p>
<p>The definition of the <code>add</code> function can be simplified using C++20's template shorthand syntax:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_concept" href="conceptlive__cells_1_1Cell.html">live_cells::Cell</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> add (<span class="keyword">const</span> Cell <span class="keyword">auto</span> &amp;a, <span class="keyword">const</span> Cell <span class="keyword">auto</span> &amp;b) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441">live_cells::computed</a>([=] {</div>
<div class="line">        <span class="keywordflow">return</span> a() + b();</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="ttc" id="aconceptlive__cells_1_1Cell_html"><div class="ttname"><a href="conceptlive__cells_1_1Cell.html">live_cells::Cell</a></div><div class="ttdoc">Defines the cell protocol.</div><div class="ttdef"><b>Definition</b> types.hpp:125</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Dynamically Typed Cells</h2>
<p>The <code>Cell</code> concept and <code>auto</code> limits you to cells for which the exact type is known at compile-time. This means you cannot use them to store cells of unrelated, and unknown, types in a container such as <code>std::vector</code>.</p>
<p>For this use case, the <code><a class="el" href="classlive__cells_1_1cell.html" title="Dynamically typed Cell container.">live_cells::cell</a></code> wrapper is provided. <code>cell</code> is a wrapper over a <code>Cell</code> that performs type erasure, much like <code>std::function</code>, in which a cell of any type can be stored.</p>
<p>A <code>cell</code> wrapper is created by providing a <code>Cell</code> to its constructor. The wrapper exposes the same methods specified by the <code>Cell</code> concept however the <a class="el" href="classlive__cells_1_1cell.html#a01d2d60e343d081b6528fba199cf299a"><code>value()</code></a> getter method is a template that has to be invoked with a type parameter, specifying the type of value to retrieve:</p>
<div class="fragment"><div class="line"><span class="comment">// A vector that can hold cells of any type</span></div>
<div class="line">std::vector&lt;live_cells::cell&gt; my_cells;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A statically typed mutable cell</span></div>
<div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A dynamically typed cell</span></div>
<div class="line"><a class="code hl_class" href="classlive__cells_1_1cell.html">live_cells::cell</a> ref_a(a);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// `ref_a` can be added to a vector whereas `a` cannot</span></div>
<div class="line">my_cells.push_back(ref_a);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Printing the value of `a` via the `cell` wrapper:</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prints: 0</span></div>
<div class="line">std::cout &lt;&lt; ref_a.value&lt;<span class="keywordtype">int</span>&gt;() &lt;&lt; std::endl;</div>
<div class="ttc" id="aclasslive__cells_1_1cell_html"><div class="ttname"><a href="classlive__cells_1_1cell.html">live_cells::cell</a></div><div class="ttdoc">Dynamically typed Cell container.</div><div class="ttdef"><b>Definition</b> observable.hpp:130</div></div>
</div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>The template type parameter provided to <code>value</code> has to match the type of the value held in the cell exactly, otherwise an <code>std::bad_cast</code> exception is thrown.</dd></dl>
<p>When the value type of the value held in the cell is known ahead of time, the <code><a class="el" href="classlive__cells_1_1typed__cell.html" title="Dynamically typed Cell container with a static value type.">live_cells::typed_cell</a></code> wrapper can be used, which is the same as <code><a class="el" href="classlive__cells_1_1cell.html" title="Dynamically typed Cell container.">live_cells::cell</a></code> but takes the value type as a template parameter:</p>
<div class="fragment"><div class="line"><span class="comment">// A vector that can hold cells of any type that hold an `int`</span></div>
<div class="line">std::vector&lt;live_cells::typed_cell&lt;int&gt;&gt; my_cells;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A statically typed mutable cell</span></div>
<div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A dynamically typed cell</span></div>
<div class="line"><a class="code hl_class" href="classlive__cells_1_1dynamic__compute__cell.html">live_cells::typed_cell&lt;int&gt;</a> ref_a(a);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// `ref_a` can be added to a vector whereas `a` cannot</span></div>
<div class="line">my_cells.push_back(ref_a);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prints: 0</span></div>
<div class="line">std::cout &lt;&lt; ref_a.value() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Notice there is no need to provide a value type template parameter to the <code>value()</code> method, because the value type (<code>int</code> in this case) is already given in the <code>typed_cell</code> template parameter.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Memory Management</h2>
<p>Cells mostly take care of their own memory management, but there are a few points to keep in mind when using cells:</p>
<ol type="1">
<li><p class="startli">A cell holds a reference to its state. This means, copying a cell does not copy the underlying state but merely creates a new reference to it:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(0);</div>
<div class="line"><span class="keyword">auto</span> b = a;</div>
<div class="line"> </div>
<div class="line">a = 10;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prints: 10</span></div>
<div class="line">std::cout &lt;&lt; b.value() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p class="startli">That's why, as you've probably noticed, the lambda functions provided to <code><a class="el" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87" title="Register a cell watch function.">live_cells::watch()</a></code> and <code><a class="el" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441" title="Create a cell with a value that is a function of one or more argument cells.">live_cells::computed()</a></code> capture cells by value, not by reference.</p>
<p class="startli">The cell state holds the cell's value and its observers.</p>
</li>
<li><p class="startli">If a lambda function can escape its scope, capture cells by value not by reference.</p>
<p class="startli">Both <code><a class="el" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87" title="Register a cell watch function.">live_cells::watch()</a></code> and <code><a class="el" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441" title="Create a cell with a value that is a function of one or more argument cells.">live_cells::computed()</a></code> store a copy of the lambda which can potentially outlive the scope in which the lambda function is defined. If a cell is captured by reference in this case, it ends up as a dangling reference.</p>
<p class="startli">On the other hand, <code><a class="el" href="namespacelive__cells.html#a7b04ad09f594427e1650b75047540f80" title="Batch changes to the values of mutable cells.">live_cells::batch()</a></code> neither copies nor stores the function provided to it but only calls it immediately. Thus it is safe to use capture by reference in this case. However, when in doubt capture by value.</p>
</li>
<li><p class="startli">The state of a cell is destroyed when the last cell referencing it is destroyed.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(0);</div>
<div class="line"><a class="code hl_class" href="classlive__cells_1_1cell.html">live_cells::cell</a> ref(a);</div>
<div class="line"> </div>
<div class="line">{ <span class="comment">// Create a new scope</span></div>
<div class="line">    <span class="keyword">auto</span> b = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(1);</div>
<div class="line">    <span class="keyword">auto</span> c = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set `ref` to `b`</span></div>
<div class="line">    ref = <a class="code hl_class" href="classlive__cells_1_1cell.html">live_cells::cell</a>(b);</div>
<div class="line">} <span class="comment">// The state of `c` is destroyed at this point</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// The state of `b` is not destroyed because `ref`</span></div>
<div class="line"><span class="comment">// is still holding a reference to it</span></div>
</div><!-- fragment --><p class="startli">In this regard, cells function much like <code>std::shared_ptr</code>.</p>
</li>
<li>Do not wrap a cell in <code>std::shared_ptr</code>. Whilst not wrong, its unnecessary because cells already have a shared pointer to their underlying state. Therefore, it's best to simply copy the cell, whether statically or dynamically typed.</li>
<li><p class="startli">Mutable cell values are assigned by value, not by reference. This probably goes without saying but its best to state it explicitly</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(std::string(<span class="stringliteral">&quot;hello&quot;</span>));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The string &quot;bye&quot; is copied into the `std::string` held by</span></div>
<div class="line"><span class="comment">// the cell.</span></div>
<div class="line">a = <span class="stringliteral">&quot;bye&quot;</span>;</div>
</div><!-- fragment --></li>
</ol>
<h1><a class="anchor" id="autotoc_md8"></a>
Next</h1>
<p>Now that we've covered the basic you can proceed to the next <a class="el" href="md_doc_22-expressions.html">section</a>, which introduces utilities for creating cells directly from expressions. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
