<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Live Cells C++: 2. Cell Expressions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Live Cells C++
   </div>
   <div id="projectbrief">Reactive Programming for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_doc_22-expressions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">2. Cell Expressions</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md9"></a> This library provides a number of tools for building expressions of cells without requiring a computed cell to be created explicitly using <code><a class="el" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441" title="Create a cell with a value that is a function of one or more argument cells.">live_cells::computed()</a></code>.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Arithmetic</h1>
<p>The arithmetic and relational (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>) operators, when applied to cells holding numeric values, return cells which compute the result of the expression.</p>
<p>This allows a computation to be defined directly as an expression of cells. For example the following cell computes the sum of two cells:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(1);</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(2);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> sum = a + b;</div>
<div class="ttc" id="anamespacelive__cells_html_ab365650aeb27f61f31622a49d4fb79a3"><div class="ttname"><a href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a></div><div class="ttdeci">mutable_cell&lt; T &gt; variable(T value)</div><div class="ttdoc">Create a new mutable cell with an initial value.</div><div class="ttdef"><b>Definition</b> mutable_cell.hpp:276</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This definition of the sum cell is not only simpler than the definition using <code><a class="el" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441" title="Create a cell with a value that is a function of one or more argument cells.">live_cells::computed()</a></code> but is also more efficient since the argument cells are determined at compile-time.</dd></dl>
<p>The <code>sum</code> cell is a cell like any other. It can be observed by a watch function or can appear as an argument in a computed cell.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> watcher = <a class="code hl_function" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87">live_cells::watch</a>([=] {</div>
<div class="line">    std::cout &lt;&lt; sum() &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">a = 5; <span class="comment">// Prints: 7</span></div>
<div class="line">b = 4; <span class="comment">// Prints: 9</span></div>
<div class="ttc" id="anamespacelive__cells_html_aff827bee503738afea0d4de923ca0e87"><div class="ttname"><a href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87">live_cells::watch</a></div><div class="ttdeci">std::shared_ptr&lt; watcher &gt; watch(F fn)</div><div class="ttdoc">Register a cell watch function.</div><div class="ttdef"><b>Definition</b> watcher.hpp:193</div></div>
</div><!-- fragment --><p>Expressions of cells can be arbitrarily complex:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> x = a * b + c / d;</div>
<div class="line"><span class="keyword">auto</span> y = x &lt; e;</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>Values appearing in a cell expression, e.g. <code>a + 1</code>, are converted to constant cells, as if by <code><a class="el" href="namespacelive__cells.html#a163ced4b8bef0f870be26c0a1e8c4c59">live_cells::value()</a></code>.</dd></dl>
<h1><a class="anchor" id="autotoc_md11"></a>
Equality</h1>
<p>Every cell overloads the <code>==</code> and <code>!=</code> operators, which return cells that compare whether the values of the cells are equal or not equal, respectively.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> eq = a == b;  <span class="comment">// eq() == true when a() == b()</span></div>
<div class="line"><span class="keyword">auto</span> neq = a != b; <span class="comment">// neq() == true when a() != b()</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md12"></a>
Logic and selection</h1>
<p>The following operator overloads and functions are provided for cells holding boolean-like value:</p>
<dl>
<dt><code>&amp;&amp;</code> </dt>
<dd>Creates a cell with a value that is the logical and of two cells </dd>
<dt><code>||</code> </dt>
<dd>Creates a cell with a value that is the logical or of two cells </dd>
<dt><code>!</code> </dt>
<dd>Creates a cell with a value which is the logical not of a cell </dd>
<dt><a class="el" href="namespacelive__cells.html#a70b163d68732a15a5f7c16b69d9ba357"><code>select</code></a> </dt>
<dd>Creates a cell which selects between the values of two cells based on a condition </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code>&amp;&amp;</code> and <code>||</code> operators overloads preserve the short-circuiting behaviour of the operators. This means the value of a cell is not referenced if the result of the expression is already known without it.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// cond() is true when a() || b() is true</span></div>
<div class="line"><span class="keyword">auto</span> cond = a || b;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// when cond() is true, cell() == c() else cell() == d()</span></div>
<div class="line"><span class="keyword">auto</span> cell = <a class="code hl_function" href="namespacelive__cells.html#a70b163d68732a15a5f7c16b69d9ba357">live_cells::select</a>(cond, c, d);</div>
<div class="line"> </div>
<div class="line">a = <span class="keyword">true</span>;</div>
<div class="line">c = 1;</div>
<div class="line">d = 2;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; cell.value() &lt;&lt; std::endl; <span class="comment">// Prints: 1</span></div>
<div class="line"> </div>
<div class="line">a = <span class="keyword">false</span>;</div>
<div class="line">b = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; cell.value() &lt;&lt; std::endl; <span class="comment">// Prints: 2</span></div>
<div class="ttc" id="anamespacelive__cells_html_a70b163d68732a15a5f7c16b69d9ba357"><div class="ttname"><a href="namespacelive__cells.html#a70b163d68732a15a5f7c16b69d9ba357">live_cells::select</a></div><div class="ttdeci">auto select(Cell auto condition, Cell auto if_true, Cell auto if_false)</div><div class="ttdoc">Create a cell which selects between the values of two cells based on the value of a condition cell.</div><div class="ttdef"><b>Definition</b> boolean.hpp:102</div></div>
</div><!-- fragment --><p>The third argument (if false) of <code><a class="el" href="namespacelive__cells.html#a70b163d68732a15a5f7c16b69d9ba357" title="Create a cell which selects between the values of two cells based on the value of a condition cell.">live_cells::select()</a></code> can be omitted, in which case the cell's value will not be updated if the condition is false:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> cell = <a class="code hl_function" href="namespacelive__cells.html#a70b163d68732a15a5f7c16b69d9ba357">live_cells::select</a>(cond, c);</div>
<div class="line"> </div>
<div class="line">cond = <span class="keyword">true</span>;</div>
<div class="line">a = 2;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; cell.value() &lt;&lt; std::endl; <span class="comment">// Prints 2</span></div>
<div class="line"> </div>
<div class="line">cond = <span class="keyword">false</span>;</div>
<div class="line">a = 4;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; cell.value() &lt;&lt; std::endl; <span class="comment">// Prints 2</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md13"></a>
Aborting a computation</h1>
<p>In the previous section we saw that <code><a class="el" href="namespacelive__cells.html#a70b163d68732a15a5f7c16b69d9ba357" title="Create a cell which selects between the values of two cells based on the value of a condition cell.">live_cells::select()</a></code> creates a cell which does not update its argument when the condition cell is <code>false</code> and its only given an if true argument. Under the hood, <code>select</code> doesn't create some special kind of cell but uses <code><a class="el" href="namespacelive__cells.html#aa16775c4657f30dc7d9e3df547ae1b8f" title="Stop the computation of the current computed cell&#39;s value.">live_cells::none()</a></code> to abort the computation.</p>
<p>When <code><a class="el" href="namespacelive__cells.html#aa16775c4657f30dc7d9e3df547ae1b8f" title="Stop the computation of the current computed cell&#39;s value.">live_cells::none()</a></code> is called inside a computed cell, the computation of the cell's value is aborted and its current value is preserved. This can be used to prevent a cell's value from being recomputed when a condition is not met:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(4);</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_function" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441">live_cells::computed</a>([=] {</div>
<div class="line">    <span class="keywordflow">if</span> (a() &gt;= 10)</div>
<div class="line">        <a class="code hl_function" href="namespacelive__cells.html#aa16775c4657f30dc7d9e3df547ae1b8f">live_cells::none</a>();</div>
<div class="line">        </div>
<div class="line">    <span class="keywordflow">return</span> a();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">a = 6;</div>
<div class="line">std::cout &lt;&lt; b.value() &lt;&lt; std::endl; <span class="comment">// Prints 6</span></div>
<div class="line"> </div>
<div class="line">a = 15;</div>
<div class="line">std::cout &lt;&lt; b.value() &lt;&lt; std::endl; <span class="comment">// Prints 6</span></div>
<div class="line"> </div>
<div class="line">a = 8;</div>
<div class="line">std::cout &lt;&lt; b.value() &lt;&lt; std::endl; <span class="comment">// Prints 8</span></div>
<div class="ttc" id="anamespacelive__cells_html_a38ef71dbf501d266974a7fae279a8441"><div class="ttname"><a href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441">live_cells::computed</a></div><div class="ttdeci">auto computed(F &amp;&amp;compute)</div><div class="ttdoc">Create a cell with a value that is a function of one or more argument cells.</div><div class="ttdef"><b>Definition</b> computed.hpp:45</div></div>
<div class="ttc" id="anamespacelive__cells_html_aa16775c4657f30dc7d9e3df547ae1b8f"><div class="ttname"><a href="namespacelive__cells.html#aa16775c4657f30dc7d9e3df547ae1b8f">live_cells::none</a></div><div class="ttdeci">void none()</div><div class="ttdoc">Stop the computation of the current computed cell's value.</div><div class="ttdef"><b>Definition</b> computed.hpp:138</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The initial value of every computed cell is the default constructed value. Thus if <code><a class="el" href="namespacelive__cells.html#aa16775c4657f30dc7d9e3df547ae1b8f" title="Stop the computation of the current computed cell&#39;s value.">live_cells::none()</a></code> is called during the first call to the cell's computation function, the default value for the cell's value type is retained.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The value of a computed cell is only computed if it is actually referenced. <code><a class="el" href="namespacelive__cells.html#aa16775c4657f30dc7d9e3df547ae1b8f" title="Stop the computation of the current computed cell&#39;s value.">live_cells::none()</a></code> only preserves the current value of the cell, but this might not be the latest value of the cell if the cell's value is only referenced conditionally. A good rule of thumb is to use <code><a class="el" href="namespacelive__cells.html#aa16775c4657f30dc7d9e3df547ae1b8f" title="Stop the computation of the current computed cell&#39;s value.">live_cells::none()</a></code> only to prevent a cell from holding an invalid value.</dd></dl>
<h1><a class="anchor" id="autotoc_md14"></a>
Exception Handling</h1>
<p>If an exception is thrown during the computation of a cell's value, it is rethrown when the value is referenced. This allows exceptions to be handled using <code>try</code> and <code>catch</code> inside computed cells:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> str = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(std::string(<span class="stringliteral">&quot;0&quot;</span>));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> n = <a class="code hl_function" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441">live_cells::computed</a>([=] {</div>
<div class="line">    <span class="keywordflow">return</span> std::stoi(str());</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> is_valid = <a class="code hl_function" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441">live_cells::computed</a>([=] {</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keywordflow">return</span> n() &gt; 0;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (...) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; is_valid.value() &lt;&lt; std::endl; <span class="comment">// Prints false</span></div>
<div class="line"> </div>
<div class="line">str = <span class="stringliteral">&quot;5&quot;</span>;</div>
<div class="line">std::cout &lt;&lt; is_valid.value() &lt;&lt; std::endl; <span class="comment">// Prints true</span></div>
<div class="line"> </div>
<div class="line">str = <span class="stringliteral">&quot;not a number&quot;</span>;</div>
<div class="line">std::cout &lt;&lt; is_valid.value() &lt;&lt; std::endl; <span class="comment">// Prints false</span></div>
</div><!-- fragment --><p>The <code><a class="el" href="namespacelive__cells.html#a62bdb9a836d990bfdfc53919a790ad17" title="Create a Cell which handles all exceptions thrown while computing the value of a cell.">live_cells::on_error()</a></code> function creates a cell that selects the value of another cell when an exception is thrown.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> str = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(std::string(<span class="stringliteral">&quot;0&quot;</span>));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> m = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(2);</div>
<div class="line"><span class="keyword">auto</span> n = <a class="code hl_function" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441">live_cells::computed</a>([=] {</div>
<div class="line">    <span class="keywordflow">return</span> std::stoi(str());</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Equal to n(). If n() throws, equal to m();</span></div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacelive__cells.html#a62bdb9a836d990bfdfc53919a790ad17">live_cells::on_error</a>(n, m);</div>
<div class="line"> </div>
<div class="line">str = <span class="stringliteral">&quot;3&quot;</span>;</div>
<div class="line">std::cout &lt;&lt; result.value() &lt;&lt; std::endl; <span class="comment">// Prints 3</span></div>
<div class="line"> </div>
<div class="line">str = <span class="stringliteral">&quot;not a number&quot;</span>;</div>
<div class="line">std::cout &lt;&lt; result.value() &lt;&lt; std::endl; <span class="comment">// Prints 2</span></div>
<div class="ttc" id="anamespacelive__cells_html_a62bdb9a836d990bfdfc53919a790ad17"><div class="ttname"><a href="namespacelive__cells.html#a62bdb9a836d990bfdfc53919a790ad17">live_cells::on_error</a></div><div class="ttdeci">auto on_error(const Cell auto &amp;cell, const Cell auto &amp;error_value)</div><div class="ttdoc">Create a Cell which handles all exceptions thrown while computing the value of a cell.</div><div class="ttdef"><b>Definition</b> errors.hpp:41</div></div>
</div><!-- fragment --><p>A template overload of <code>on_error</code> is provided, which takes an exception type as a template type parameter. When this overload is used only exceptions of the given type are handled.</p>
<div class="fragment"><div class="line"><span class="comment">// Only handles std::invalid_argument exceptions</span></div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_class" href="classlive__cells_1_1dynamic__compute__cell.html">live_cells::on_error&lt;std::invalid_argument&gt;</a>(n, m);</div>
<div class="ttc" id="aclasslive__cells_1_1dynamic__compute__cell_html"><div class="ttname"><a href="classlive__cells_1_1dynamic__compute__cell.html">live_cells::dynamic_compute_cell</a></div><div class="ttdoc">A computed cell which determines its argument cells at runtime.</div><div class="ttdef"><b>Definition</b> dynamic_compute_cell.hpp:136</div></div>
</div><!-- fragment --><p>The validation logic in the previous example can be implemented more succinctly using:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> str = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(<span class="stringliteral">&quot;0&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> n = <a class="code hl_function" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441">live_cells::computed</a>([=] {</div>
<div class="line">    <span class="keywordflow">return</span> std::stoi(str());</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> is_valid = on_error(</div>
<div class="line">    n &gt; 0,</div>
<div class="line">    <a class="code hl_function" href="namespacelive__cells.html#a163ced4b8bef0f870be26c0a1e8c4c59">live_cells::value</a>(<span class="keyword">false</span>)</div>
<div class="line">);</div>
<div class="ttc" id="anamespacelive__cells_html_a163ced4b8bef0f870be26c0a1e8c4c59"><div class="ttname"><a href="namespacelive__cells.html#a163ced4b8bef0f870be26c0a1e8c4c59">live_cells::value</a></div><div class="ttdeci">constant_cell&lt; T &gt; value(const T &amp;value)</div><div class="ttdef"><b>Definition</b> constant_cell.hpp:132</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We used <code>live_cells::value(false)</code> to create a constant cell that holds the values <code>false</code>.</dd></dl>
<h1><a class="anchor" id="autotoc_md15"></a>
Peeking Cells</h1>
<p>What if you want to use the value of a cell in a computed cell but don't want changes to that cell's value triggering a recomputation? The <code><a class="el" href="namespacelive__cells.html#a7fc8173d64b8688a70ff408450e8b91e" title="Create a Cell that reads the value of cell but does not notify its observers when the value has chang...">live_cells::peek()</a></code> function allows you to do exactly that.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(0);</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code hl_function" href="namespacelive__cells.html#ab365650aeb27f61f31622a49d4fb79a3">live_cells::variable</a>(1);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> c = <a class="code hl_function" href="namespacelive__cells.html#a38ef71dbf501d266974a7fae279a8441">live_cells::computed</a>([=] {</div>
<div class="line">    <span class="keywordflow">return</span> a() + <a class="code hl_function" href="namespacelive__cells.html#a7fc8173d64b8688a70ff408450e8b91e">live_cells::peek</a>(b);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> watch = <a class="code hl_function" href="namespacelive__cells.html#aff827bee503738afea0d4de923ca0e87">live_cells::watch</a>([=] {</div>
<div class="line">    std::cout &lt;&lt; c() &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">a = 3; <span class="comment">// Prints: 4</span></div>
<div class="line">b = 5; <span class="comment">// Doesn&#39;t print anything</span></div>
<div class="line">a = 7; <span class="comment">// Prints: 13</span></div>
<div class="ttc" id="anamespacelive__cells_html_a7fc8173d64b8688a70ff408450e8b91e"><div class="ttname"><a href="namespacelive__cells.html#a7fc8173d64b8688a70ff408450e8b91e">live_cells::peek</a></div><div class="ttdeci">auto peek(const C &amp;cell)</div><div class="ttdoc">Create a Cell that reads the value of cell but does not notify its observers when the value has chang...</div><div class="ttdef"><b>Definition</b> peek_cell.hpp:130</div></div>
</div><!-- fragment --><p>In the above example cell <code>c</code> is a computed cell referencing the value of <code>a</code> and <em>peeks</em> the value of <code>b</code>. Changing the value of <code>a</code> triggers a recomputation of <code>c</code>, and hence triggers the watch function which prints to standard output, but changing the value of <code>b</code> doesn't trigger a recomputation of <code>c</code>.</p>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="namespacelive__cells.html#a7fc8173d64b8688a70ff408450e8b91e" title="Create a Cell that reads the value of cell but does not notify its observers when the value has chang...">live_cells::peek()</a></code> returns a cell.</dd></dl>
<p>You may be asking why do we need <code><a class="el" href="namespacelive__cells.html#a7fc8173d64b8688a70ff408450e8b91e" title="Create a Cell that reads the value of cell but does not notify its observers when the value has chang...">live_cells::peek()</a></code> here instead of just accessing the value of <code>b</code> directly using <code>b.value()</code>. Something we've glossed over till this point is the lifecycle of cells. Cells are only active while they are actually observed, and are activated when the first observer is added. While active, cells react to changes in their argument cells. When the last observer is removed, cells are deactivated and stop observing their argument cells. When a new observer is added, they are reactivated again. Essentially, this means that the value of a cell may no longer be current if it doesn't have at least one observer. For a computed cell this is not a problem, since when it is inactive it computes its value on demand, but it may cause issues with other cells. The <code><a class="el" href="namespacelive__cells.html#a7fc8173d64b8688a70ff408450e8b91e" title="Create a Cell that reads the value of cell but does not notify its observers when the value has chang...">live_cells::peek()</a></code> function takes care of adding an observer to the peeked cell, so that it remains active, but at the same time prevents the observers, added through <code><a class="el" href="namespacelive__cells.html#a7fc8173d64b8688a70ff408450e8b91e" title="Create a Cell that reads the value of cell but does not notify its observers when the value has chang...">live_cells::peek()</a></code>, from being notified of changes in its value.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Pipe Operator</h1>
<p>The <code><a class="el" href="namespacelive__cells_1_1ops.html">live_cells::ops</a></code> namespace provides a collection of operators which can be applied on cells using the <code>|</code> operator.</p>
<p>For example the <a class="el" href="namespacelive__cells.html#a70b163d68732a15a5f7c16b69d9ba357"><code>select</code></a> function, introduced earlier, can also be applied on the condition cell with the following:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> cell = cond | <a class="code hl_function" href="namespacelive__cells_1_1ops.html#aa25117cbccbcc2aba58d31ffe52f6014">live_cells::ops::select</a>(c, d);</div>
<div class="ttc" id="anamespacelive__cells_1_1ops_html_aa25117cbccbcc2aba58d31ffe52f6014"><div class="ttname"><a href="namespacelive__cells_1_1ops.html#aa25117cbccbcc2aba58d31ffe52f6014">live_cells::ops::select</a></div><div class="ttdeci">auto select(const Cell auto &amp;if_true)</div><div class="ttdoc">Create an Operator for conditionally selecting the value of another cell based on the value of the op...</div><div class="ttdef"><b>Definition</b> boolean.hpp:148</div></div>
</div><!-- fragment --><p>which is equivalent to:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> cell = <a class="code hl_function" href="namespacelive__cells.html#a70b163d68732a15a5f7c16b69d9ba357">live_cells::select</a>(cond, c, d);</div>
</div><!-- fragment --><p>The <code><a class="el" href="namespacelive__cells_1_1ops.html">live_cells::ops</a></code> package also provides a variant of <a class="el" href="namespacelive__cells.html#a62bdb9a836d990bfdfc53919a790ad17"><code>on_error</code></a> and <a class="el" href="namespacelive__cells.html#a7fc8173d64b8688a70ff408450e8b91e"><code>peek</code></a> that can be used with the pipe operator. This allows for a reactive pipeline to be built without nested function calls.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> cell = cond </div>
<div class="line">    | <a class="code hl_function" href="namespacelive__cells_1_1ops.html#aa25117cbccbcc2aba58d31ffe52f6014">live_cells::ops::select</a>(a, b) </div>
<div class="line">    | <a class="code hl_function" href="namespacelive__cells_1_1ops.html#a420eb19acffbe7bee8acfa79c7757e1a">live_cells::ops::on_error</a>(c) </div>
<div class="line">    | <a class="code hl_variable" href="namespacelive__cells_1_1ops.html#ac3c694eb320f49f96fd11a5601417fec">live_cells::ops::peek</a>;</div>
<div class="ttc" id="anamespacelive__cells_1_1ops_html_a420eb19acffbe7bee8acfa79c7757e1a"><div class="ttname"><a href="namespacelive__cells_1_1ops.html#a420eb19acffbe7bee8acfa79c7757e1a">live_cells::ops::on_error</a></div><div class="ttdeci">auto on_error(const Cell auto &amp;error_value)</div><div class="ttdoc">Create an Operator for handling exceptions thrown by the operand Cell.</div><div class="ttdef"><b>Definition</b> errors.hpp:99</div></div>
<div class="ttc" id="anamespacelive__cells_1_1ops_html_ac3c694eb320f49f96fd11a5601417fec"><div class="ttname"><a href="namespacelive__cells_1_1ops.html#ac3c694eb320f49f96fd11a5601417fec">live_cells::ops::peek</a></div><div class="ttdeci">constexpr auto peek</div><div class="ttdoc">Operator for reading the value of a cell without reacting to changes.</div><div class="ttdef"><b>Definition</b> peek_cell.hpp:147</div></div>
</div><!-- fragment --><p>This is equivalent to:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> cell = <a class="code hl_function" href="namespacelive__cells.html#a7fc8173d64b8688a70ff408450e8b91e">live_cells::peek</a>(</div>
<div class="line">    <a class="code hl_function" href="namespacelive__cells.html#a62bdb9a836d990bfdfc53919a790ad17">live_cells::on_error</a>(</div>
<div class="line">        <a class="code hl_function" href="namespacelive__cells.html#a70b163d68732a15a5f7c16b69d9ba357">live_cells::select</a>(cond, a, b),</div>
<div class="line">        c</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md17"></a>
Next</h1>
<p>The next <a class="el" href="md_doc_23-two-way-data-flow.html">section</a> introduces two-way data flow. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
